<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Architectures Orientées Web</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/sky.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h3>Architectures Orientées Web</h3>
<!-- http://blog.octo.com/larchitecture-microservices-sans-la-hype-quest-ce-que-cest-a-quoi-ca-sert-est-ce-quil-men-faut/ -->
    <aside class="notes">
        Pas trop de détails sur les languages, frameworks ou implémentations.
    </aside>
			</section>
			<section>
				<section>
					<h4>L'application à installer</h4>
					<ul>
						<li>On la télécharge (ou on insère un CD / DVD)</li>
						<li>Puis on l'installe sur son ordinateur</li>
						<li>Exemple : Word ou Excel</li>
					</ul>
				</section>
				<section>
					<table>
						<thead>
							<tr><th>Avantages</th><th>Inconvénients</th></tr>
						</thead>
						<tbody>
							<tr><td>Utilisable offline</td><td>Livraison<br>Installation<br>Mises à jours<br>Dépendant de l'OS</td></tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<section><h4>Architectures orientées services</h4>
					<ul>
						<li>C'est une représentation logique d'une activité métier avec un résultat attendu.</li>
						<li>Elle est auto-contenue.</li>
						<li>C'est une boite noire pour ses utilisateurs.</li>
						<li>Elle peut être composée de sous-services.</li>
						<li>Exemple : Google Docs</li>
					</ul>
				</section>
				<section>
					<h5>Principes fondateurs</h5>
					<ul>
						<li>La valeur métier est plus importante que la stratégie technique.</li>
						<!-- <li>Des cibles stratégiques sont plus importantes que les bénéfices des projets spécifiques.</li> -->
						<li>L'inter-operabilité intrinsèque est plus importante que les intégrations spécifiques.</li>
						<li>Il vaut mieux avoir des services génériques partagés que des implémentations spécifiques.</li>
						<li>La flexibilité est plus importante que l'optimisation.</li>
						<li>Il vaut mieux rafiner progressivement qu'essayer de faire parfait dès le début.</li>
					</ul>
				</section>
				<section>
					Pas de standard quand à la composition d'une architecture orientée services. Les services sont en général :<br>
					<ul>
						<li>Contractualisés</li>
						<li>Autonomes</li>
						<li>Accessibles</li>
						<li>Boîtes noires</li>
						<li>Granulaires</li>
						<li>Composables</li>
						<li>Réutilisables</li>
						<li>(Auto-découvrables)</li>
						<li>(Composés de services qui n'etaient pas prévus pour une architecture SOA)</li>
					</ul>
				</section>
				<section>
					<table>
						<thead>
							<tr><th>Avantages</th><th>Inconvénients</th></tr>
						</thead>
						<tbody>
							<tr><td>Pas de livraison<br>Pas d'installation<br>Mises à jours automatiques<br>Indépendant de l'OS</td><td>Nécessite une connection internet</td></tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<section>
					<h4>Services Web</h4>
						<ul>
							<li>Services de type SOAP</li>
							<li>Services de type REST</li>
						</ul>
					voir la page wikipédia et developper
					<h4>Web_API</h4>

					voir la page wikipédia et developper

					REST car simple et stateless -> a developper ? CRUD exemple
				</section>
				<section>Exemples
					<ul>
						<li>Contractualisés => swagger</li>
						<li>Autonomes</li>
						<li>Accessibles => DNS</li>
						<li>Boîtes noires</li>
						<li>Granulaires</li>
						<li>Composables</li>
						<li>Réutilisables</li>
						<li>(Auto-découvrables)</li>
						<li>(Composés de services qui n'etaient pas prévus pour une architecture SOA)</li>
					</ul>
				 </section>
			</section>
			<section>
				<section><h4>L'architecture micro-services</h4>
					<ul>
						<li>Apparue au début de la décénie</li>
						<li>Popularisée par Netflix</li>
						<li>Considérée (a tord) comme un remède miracle</li>
					</ul>
				</section>
				<section>
					<h5>Principe</h5>
					La philosophie est identique à celle du monde UNIX : "Faire une seule chose mais bien le faire".
					<ul>
						<li>Les services sont petits et ne font qu'une seule fonction.</li>
						<li>Le déploiement et le test automatique sont indispensables. Sans ca les opérationels ne peuvent pas suivre et les différentes équipes ne peuvent pas travailler indépendament sur des fonctionnalités différentes.</li>
						<li>Durant la conception, il faut vivre avec les erreur et les pannes, quite à en provoquer.</li>
						<li>Chaque service est élastique, résistant, composable, minimal et complet.</li>
					</ul>
				</section>
				<section>
					<table>
						<thead>
							<tr><th>Avantages</th><th>Inconvénients</th></tr>
						</thead>
						<tbody>
							<tr><td>Maintenance simplifiée et moins coûteuse</td><td>Coût initial supérieur</td></tr>
						</tbody>
					</table>
				</section>
				<section>
					<h5>Exemple : redimensionnement de miniature</h5>
					L'utilisateur charge une photo ou image pour son profil et celle ci ets redimensionnée automatiquement pour bien s'intégrer au site.
				</section>
				<section>
					<h5>Eviter les nano-services (1)</h5>
					<ul>
						<li>Les micro-services trop petits sont un anti-pattern</li>
						<li>Surcharge de code écrit (et donc de bugs)</li>
						<li>Surcharge d'exécution : transformations, trafic réseau, ...</li>
						<li>Logique fragmentée : la fonctionnalité est distribuée sur plusieurs services => surcoût de conception et de maintenance</li>
					</ul>
				</section>
				<section>
					<h5>Eviter les nano-services (2)</h5>
					<ul>
						<li>Packager une fonctionnalité en tant que librairie plutot que service</li>
						<li>Combiner la fonctionnalité avec d'autres pour avoir un service un peu plus conséquent</li>
						<li>Refactoriser le système : refaire son design ou mettre la fonctionnalité dans d'autres services existants</li>
					</ul>
				</section>
			</section>
			<section>
				<section>Transition d'un gros service a plusieur (Aka pelage du monolithe - terme a revoir ?)</section>
				<section>Big-bang = cata, boum</section>
				<section>Une orange (pomme ?) en train d'etre pelée</section>

			</section>
			<section>
				<section>Automatisation (image robot)</section>
				<section>Besoin de devops</section>
				<section>build</section>
				<section>intégration continue</section>
				<section>déploiement livraison continue</section>
				<section>Docker ? Containener as a service</section>

			</section>
			<section>
				<section>Misc a bien replacer dans la présentation</section>
				<section>Monitoring</section>
				<section>Proxy mastering</section>
				<section>Load balancing</section>
				<section>Avenement du cloud, c'est trop facile :P</section>
				<section>Différents type de BD - triangle avec 2 feat sur 3 possible seulement</section>
				<section>Faut pas oublier l'expérience utilisateur, faut que ca trace</section>
				<section>La doc !!! (swagger)</section>
				<section>(alban qui présente ?) Les stacks pour y parvenir - la stack mean en détail<section>
				<section>Tout est API (image)</section>
				<section>API gateway</section>
			</section
		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			history: true,

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [{
				src: 'plugin/markdown/marked.js'
			}, {
				src: 'plugin/markdown/markdown.js'
			}, {
				src: 'plugin/notes/notes.js',
				async: true
			}, {
				src: 'plugin/highlight/highlight.js',
				async: true,
				callback: function() {
					hljs.initHighlightingOnLoad();
				}
			}]
		});
	</script>
</body>

</html>
